# 7.2 接口类型

io包定义了很多有用的接口：
+ io.Writer ： 抽象了所有写入字节的类型，下面会列举
+ io.Reader ： 抽象了所有可以读取字节的类型
+ io.Closer ： 抽象了所有可以关闭的类型，比如文件或者网络连接

io.Writer 是一个广泛使用的接口，它负责所有可以写入字节的抽象，包括但不限于下面列举的这些：
+ 文件
+ 内存缓冲区
+ 网络连接
+ HTTP客户端
+ 打包器（archiver）
+ 散列器（hasher）

# 7.5 接口值
**接口值**，就是一个接口类型的值。分两个部分：
+ **动态类型** ： 该接口的具体类型
+ **动态值** ： 该具体类型的一个值

```go
var w io.Writer  // 声明接口，动态类型和动态值都是nil
w = os.Stdout  // 有动态类型，也有动态值
w = io.Writer(os.Stdout)  // 和上面这句等价，把一个具体类型显式转换为接口类型
w = new(bytes.Buffer)  // 有动态类型，也有动态值
w = nil  // 把动态类型和动态值都设置为nil，恢复到声明时的状态
```

## 比较接口值
接口值可以用 == 和 != 来比较。动态类型一致，然后动态值相等（使用动态类型的 == 来比较），那么接口值相等。接口值都是nil也是相等的。  
**可以作为map的key**，也可以作为switch语句的操作数，因为可以比较。  
动态值可能是不可比较的类型，比如切片。对这样的接口进行比较，就会Panic。把这样的接口用作map的key或者switch语句的操作数时也同样会Panic。所以，仅在能确认接口值包含的动态值可以比较时，才比较接口值。  
fmt 包的 %T 打印出来的就是动态类型。在内部实现中，fmt 用反射来拿到接口动态类型的名字。

## 注意：含有空指针的非空接口
空的接口值（动态类型和动态值都为空）和仅仅动态值为nil的接口值是不一样的。
```go
const debug = true

func main() {
	var buf *bytes.Buffer
	if debug {
		buf = new(bytes.Buffer)
	}
	f(buf)
	if debug {
		// ...使用 buf...
	}
}

// 如果 out 不是 nil，那么会向其写入输出的数据
func f(out io.Writer) {
	// ...其他代码...
	if out != nil {
		out.Write([]byte("done\n"))
	}
}
```
这里，把一个类型为 \*bytes.Buffer 的空指针赋给了 out 参数，此时 out 的动态值为空。但它的动态类型是 \*bytes.Buffer。就是说 out 是一个包含空指针的非空接口，所以这里的检查 `out != nil` 是 true，防御不了这种情况。  
对于某些类型，比如 \*os.File，空接收值是合法的。但是对于这里的 \*buyes.Buffer，要求接收者不能为空，于是运行时会Panic。  
这里的解决方案是，把 main 函数中的 buf 类型修改为 io.Writer，从而避免在最开始就把一个功能不完整的值赋给一个接口：
```go
var buf io.Writer
if debug {
	buf = new(bytes.Buffer)
}
f(buf)
```

# 7.9 示例：表达式求值器
这篇有点难，没完全理解。  
TODO: 11.3 有针对这个功能编写的单元测试。

## 接口的处理
开始，先确定要使用一个接口 Expr 来代表这种语言的任意一个表达式。暂时没有任何方法，稍后再逐个添加：
```go
type Expr interface{}
```
定义好各种类型后，发现每个类型都需要提供一个 Eval 方法，于是加把这个方法加到接口中：
```go
type Expr interface {
	// 返回表达式在 env 上下文下的值
	Eval(env Env) float64
}
```
然后去定义每个类型的 Eval 方法来满足接口。都实现了之后，发现可能会有不规范的输入会使得某些方法可能会失败。所有这些错误可以在求值之前做检查来发现，所以还需要一个Check方法。不过暂时可以先不管Check方法，而是先测试 Eval 方法。

## Parse 函数
书上没有足够的空间来显示 Parse 函数，所以没有过多的解释。  
但是这部分是最难的理解的，代码实现主要使用了 text/scanner 包，也没有任何的解释和包的用法。  
TODO: 在12.6节，再次用到了这个包来进行解码，这里对使用做了介绍。

## Check 方法
测试功能都通过后，就开始考虑给 Expr 加上 Check 方法用于在表达式语法数上检查静态错误：
```go
type Expr interface {
	Eval(env Env) float64
	// Check 方法报告表达式中的错误，并把表达式中额变量加入 Vars 中
	Check(vars map[Var]bool) error
}

```
这个方法有一个 vars 参数，作用比较特殊，主要是递归方便。Check 的输入参数是一个 Var 集合，它收集在表达式中发现的变量名。从逻辑来讲，这个集合应当是 Check 的输出结果而不是输入参数，但因为这个方法是递归的，在这种情况下使用参数更为方便。调用方在最初时需要提供一个空的集合。
现在要去为每个类型再实现一个 Check 方法来满足接口。

## 绘图
3。2 节，使用浮点数绘制SVG矢量图。现在用上这个表达式求值器的话，可以更加灵活。直接通过Get请求的参数提供计算公式。当然需要做一下修改才能用上。

# 7.10 类型断言
类型断言是一个作用在接口值上的操作，代码类似于`x(T)`，x是一个接口类型的表达式，而T是一个类型（称为断言类型）。类型断言会检查操作数的动态类型是否满足指定的断言类型。  
这里有两种可能：
+ 断言类型T是一个具体类型
+ 断言类型T是一个接口类型

**具体类型**  
如果断言类型T是一个具体类型，断言类型会检查x的动态类型是否就是T。如果检查成功，返回x的动态值，返回的类型就是T。如果检查失败，那么操作崩溃。  

**接口类型**  
如果断言类型T是一个接口类型，断言类型会检查x的动态类型是否满足T。如果检查成功，动态值并没有提取出来，仍然是一个接口值，接口值的类型和值部分也不会变，只是结果类型为接口类型T。就是说，这里类型断言就是一个接口值表达式，从一个接口类型变为拥有另外一套方法的接口类型，但保留了接口值中动态类型和动态值部分。如果检查失败还是会崩溃。  

类型断言可以返回两个结果，此时操作不会因为检查失败而崩溃。多出来的返回值是一个布尔型，用来指示断言是否成功。按照惯例，一般变量名用ok。如果操作失败，ok为false，而第一个返回值会是断言类型的零值。  

# 7.12 通过接口类型来查询特性（io.md）
下面这段代码要往某个地方，写入一段字符信息。可能是http服务返回的信息，也可以是文件或者缓冲区，只要是 io\.Writer 接口就行：
```go
func writeMsg(w io.Writer, msg string) error {
	if _, err := w.Write([]byte(msg)); err != nil {
		return err
	}
	return nil
}
```
因为 Write 方法需要一个字节切片（[]byte），而需要写入的是一个字符串，所以要做类型转换。这种转换需要进行内存分配和内存复制，但复制后内存又会被马上抛弃。这里就会有性能问题，这个内存分配会导致性能下降，需要避开这个内存分配。  
如果深入查看 net\/http 包，这里w对应的动态类型还支持一个能高效写入字符串的 WriteString 方法，这个方法就避免了内存的分配。另外还有很多实现了 io\.Writer 的重要类也有 WriteString 方法，比如： \*bytes\.Buffer、\*os\.File 和 \*bufio\.Write。但是这里并不能假定 io\.Write 一定就有 WriteString 方法。这里可以定义一个新的接口，这个接口只包含 WriteString 方法，然后使用类型断言来判断w的动态类型是否满足这个新接口：
```go
// 将s写入w，如果w有WriteString方法，就直接调用该方法
func writeString(w io.Writer, s string) (n int, err error) {
	type stringWriter interface {
		WriteString(string) (n int, err error)
	}
	if sw, ok := w.(stringWriter); ok {
		return sw.WriteString(s) // 避免了内存复制
	}
	return w.Write([]byte(s)) // 分配了临时内存
}

func writeMsg(w io.Writer, msg string) error {
	if _, err := writeString(w, msg); err != nil {
		return err
	}
	return nil
}
```
为了避免代码重复，这里把检查挪到了工具函数 writeString 中。实际上，标准库提供了 io\.WriteString 函数，上面例子中的 stringWriter 接口定义和 writeString 函数就是和 io 包中的代码几乎一样的。这也是向 io.Writer 写入字符串的推荐方法。  

# 7.13 类型分支
接口有两种不同的风格。  
第一种风格下，典型的比如：io\.Reader、io\.Writer、fmt\.Stringer、sort\.Interface、http\.Handler 和 error。接口上的各种方法突出了满足这个接口的具体类型之间的相似性，但隐藏了各个具体类型的布局和各自特有的功能。这种风格强调了方法，而不是具体类型。  
第二种风格则充分利用了接口值能够容纳各种具体类型的能力，它把接口作为这些类型的**联合**（union）来使用。类型断言用来在运行时区分这些类型并分别处理。这这种风格中，强调的是满足这个接口的具体类型，而不是这个接口的方法（经常是没变方法的空接口），也不注重信息隐藏。这种风格的接口使用方式称为**可识别联合**（discriminated union）。
如果对面向对象熟悉，这两种风格分别对应：
+ **子类型多态**（subtype polymorphism）
+ **特设多态**（ad hoc polymorphism）

# 7.15 一些建议
不要一开始就定义接口，每个接口却只是一个单独的实现。这种接口是不必要的抽象，还会有运行时的成本。仅在有两个或多个具体类型需要按统一的方式处理时才需要接口。  
上面的建议也有特例，如果接口和类型实现出于依赖的原因不能放在同一个包里边，那么一个接口只有一个具体类型实现也是可以的。在这种情况下，接口是一种解耦两个包的好方式。  