# 7.2 接口类型

io包定义了很多有用的接口：
+ io.Writer ： 抽象了所有写入字节的类型，下面会列举
+ io.Reader ： 抽象了所有可以读取字节的类型
+ io.Closer ： 抽象了所有可以关闭的类型，比如文件或者网络连接

io.Writer 是一个广泛使用的接口，它负责所有可以写入字节的抽象，包括但不限于下面列举的这些：
+ 文件
+ 内存缓冲区
+ 网络连接
+ HTTP客户端
+ 打包器（archiver）
+ 散列器（hasher）

# 7.5 接口值
**接口值**，就是一个接口类型的值。分两个部分：
+ **动态类型** ： 该接口的具体类型
+ **动态值** ： 该具体类型的一个值

```go
var w io.Writer  // 声明接口，动态类型和动态值都是nil
w = os.Stdout  // 有动态类型，也有动态值
w = io.Writer(os.Stdout)  // 和上面这句等价，把一个具体类型显式转换为接口类型
w = new(bytes.Buffer)  // 有动态类型，也有动态值
w = nil  // 把动态类型和动态值都设置为nil，恢复到声明时的状态
```

## 比较接口值
接口值可以用 == 和 != 来比较。动态类型一致，然后动态值相等（使用动态类型的 == 来比较），那么接口值相等。接口值都是nil也是相等的。  
**可以作为map的key**，也可以作为switch语句的操作数，因为可以比较。  
动态值可能是不可比较的类型，比如切片。对这样的接口进行比较，就会Panic。把这样的接口用作map的key或者switch语句的操作数时也同样会Panic。所以，仅在能确认接口值包含的动态值可以比较时，才比较接口值。  
fmt 包的 %T 打印出来的就是动态类型。在内部实现中，fmt 用反射来拿到接口动态类型的名字。

## 注意：含有空指针的非空接口
空的接口值（动态类型和动态值都为空）和仅仅动态值为nil的接口值是不一样的。
```go
const debug = true

func main() {
	var buf *bytes.Buffer
	if debug {
		buf = new(bytes.Buffer)
	}
	f(buf)
	if debug {
		// ...使用 buf...
	}
}

// 如果 out 不是 nil，那么会向其写入输出的数据
func f(out io.Writer) {
	// ...其他代码...
	if out != nil {
		out.Write([]byte("done\n"))
	}
}
```
这里，把一个类型为 \*bytes.Buffer 的空指针赋给了 out 参数，此时 out 的动态值为空。但它的动态类型是 \*bytes.Buffer。就是说 out 是一个包含空指针的非空接口，所以这里的检查 `out != nil` 是 true，防御不了这种情况。  
对于某些类型，比如 \*os.File，空接收值是合法的。但是对于这里的 \*buyes.Buffer，要求接收者不能为空，于是运行时会Panic。  
这里的解决方案是，把 main 函数中的 buf 类型修改为 io.Writer，从而避免在最开始就把一个功能不完整的值赋给一个接口：
```go
var buf io.Writer
if debug {
	buf = new(bytes.Buffer)
}
f(buf)
```

# 7.9 示例：表达式求值器
这篇有点难，没完全理解。  

## 接口的处理
开始，先确定要使用一个接口 Expr 来代表这种语言的任意一个表达式。暂时没有任何方法，稍后再逐个添加：
```go
type Expr interface{}
```
定义好各种类型后，发现每个类型都需要提供一个 Eval 方法，于是加把这个方法加到接口中：
```go
type Expr interface {
	// 返回表达式在 env 上下文下的值
	Eval(env Env) float64
}
```
然后去定义每个类型的 Eval 方法来满足接口。都实现了之后，发现可能会有不规范的输入会使得某些方法可能会失败。所有这些错误可以在求值之前做检查来发现，所以还需要一个Check方法。不过暂时可以先不管Check方法，而是先测试 Eval 方法。

## Parse 函数
书上没有足够的空间来显示 Parse 函数，所以没有过多的解释。  
但是这部分是最难的理解的，代码实现主要使用了 text/scanner 包，也没有任何的解释和包的用法。

## Check 方法
测试功能都通过后，就开始考虑给 Expr 加上 Check 方法用于在表达式语法数上检查静态错误：
```go
type Expr interface {
	Eval(env Env) float64
	// Check 方法报告表达式中的错误，并把表达式中额变量加入 Vars 中
	Check(vars map[Var]bool) error
}

```
这个方法有一个 vars 参数，作用比较特殊，主要是递归方便。Check 的输入参数是一个 Var 集合，它收集在表达式中发现的变量名。从逻辑来讲，这个集合应当是 Check 的输出结果而不是输入参数，但因为这个方法是递归的，在这种情况下使用参数更为方便。调用方在最初时需要提供一个空的集合。
现在要去为每个类型再实现一个 Check 方法来满足接口。

## 绘图
3。2 节，使用浮点数绘制SVG矢量图。现在用上这个表达式求值器的话，可以更加灵活。直接通过Get请求的参数提供计算公式。当然需要做一下修改才能用上。

# 7.10 类型断言
类型断言是一个作用在接口值上的操作，代码类似于`x(T)`，x是一个接口类型的表达式，而T是一个类型（称为断言类型）。类型断言会检查操作数的动态类型是否满足指定的断言类型。  
这里有两种可能：
+ 断言类型T是一个具体类型
+ 断言类型T是一个接口类型

**具体类型**  
如果断言类型T是一个具体类型，断言类型会检查x的动态类型是否就是T。如果检查成功，返回x的动态值，返回的类型就是T。如果检查失败，那么操作崩溃。  

**接口类型**  
如果断言类型T是一个接口类型，断言类型会检查x的动态类型是否满足T。如果检查成功，动态值并没有提取出来，仍然是一个接口值，接口值的类型和值部分也不会变，只是结果类型为接口类型T。就是说，这里类型断言就是一个接口值表达式，从一个接口类型变为拥有另外一套方法的接口类型，但保留了接口值中动态类型和动态值部分。如果检查失败还是会崩溃。  

类型断言可以返回两个结果，此时操作不会因为检查失败而崩溃。多出来的返回值是一个布尔型，用来指示断言是否成功。按照惯例，一般变量名用ok。如果操作失败，ok为false，而第一个返回值会是断言类型的零值。  