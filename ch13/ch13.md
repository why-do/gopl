# 底层编程
主要内容：
+ unsafe 包
+ cgo 工具

包 unsafe 广泛使用在和操作系统交互的低级包中, 例如 runtime、os、syscall、net 等，但是普通程序是不需要使用它的。  

# 13.1 unsafe.Sizeof、Alignof 和 Offsetof
函数 unsafe\.Sizeof 报告传递给它的参数在内存中占用的字节（Byte）长度（1Byte=8bit，1个字节是8位），参数可以是任意类型的表达式，但它不会对表达式进行求值。对 Sizeof 的调用会返回一个 uintptr 类型的常量表达式，所以返回的结果可以作为数组类型的长度大小，或者用作计算其他的常量：
```go
fmt.Println(unsafe.Sizeof(float64(0))) // "8"
fmt.Println(unsafe.Sizeof(uint8(0))) // "1"
```
函数 Sizeof 仅报告每个数据结构固定部分的内存占用的字节长度。以字符串为例，报告的只是字符串对应的指针的字节长度，而不是字符串内容的长度：
```go
func main() {
	var x string
	x = "a"
	fmt.Println(unsafe.Sizeof(x), len(x)) // "16 1"

	var s []string
	for i := 0; i < 10000; i++ {
		s = append(s, "Hello")
	}
	x = strings.Join(s, ", ")
	fmt.Println(unsafe.Sizeof(x), len(x)) // "16 69998"
}
```
无论字符串多长，unsafe.Sizeof 返回的大小总是一样的。  

Go 语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小都是1个字（word），转换为字节数，在32位系统上是4个字节，在64位系统上是8个字节。  

| 类型 | 大小 |
|-----|-----|
| bool | 1个字节 |
| intN, uintN, floatN, complexN | N/8个字节(例如float64是8个字节) |
| int, uint, uintptr | 1个字 |
| *T | 1个字 |
| string | 2个字(data,len) |
| []T | 3个字(data,len,cap) |
| map | 1个字 |
| func | 1个字 |
| chan | 1个字 |
| interface | 2个字(type,value) |

## 内存对齐
在类型的值在内存中**对齐**的情况下，计算机的加载或者写入会很高效。例如，int16的大小是2字节地址应该是偶数，rune类型的大小是4字节地址应该是4的倍数，float64、uint64 或 64位指针的大小是8字节地址应该是8的倍数。对于更大倍数的地址对齐是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。  

**结构体的内存对齐**  
因此，聚合类型（结构体或数组）的值的长度至少是它的成员或元素的长度之和。并且由于“内存间隙”的存在，可能还会更大一些。内存空位是由编译器添加的未使用的内存地址，用来确保连续的成员或元素相对于结构体或数组的起始地址是对齐的。  
语言规范不要求结构体成员声明的顺序对应内存中的布局顺序，所以在理论上，编译器可以自由安排，但实际上并没有这么做。如果结构体成员的类型是不同的，不同的排列顺序可能使得结构体占用的内存不同。比如下面的三个结构体拥有相同的成员，但是第一种写法比其他两个定义需要占更多内存：
```go
                               // 64-bit  32-bit
struct{ bool; float64; int16 } // 3 words 4words
struct{ float64; int16; bool } // 2 words 3words
struct{ bool; int16; float64 } // 2 words 3words
```
对齐算法太底层了（虽然貌似也没有特别难），但确实不值得担心每个结构体的内存布局，不过高效排列可以使数据结构更加紧凑。一个容易掌握的建议是，将相同类型的成员定义在一起有可能更节约内存空间。

## 另两个函数
函数 unsafe\.Alignof 报告它参数类型所要求的对齐方式。和 Sizeof 一样，它的参数可以是任意类型的表达式，并且返回一个常量。通常情况下布尔和数值类型对齐到它们的长度(最多8个字节), 其它的类型则按字（word）对齐。  

函数 unsafe\.Offsetof，参数必须是结构体 x 的一个字段 x.f。函数返回 f 相对于结构体 x 起始地址的偏移值，如果有内存空位，也会计算在内。  

虽然这几个函数在不安全的unsafe包里，但是这几个函数是安全的，特别在需要优化内存空间时它们返回的结果对于理解原生的内存布局很有帮助。  

# 13.2 unsafe.Pointer
很多指针类型都写做 \*T，意思是“一个指向T类型变量的指针”。unsafe\.Pointer 类型是一种特殊类型的指针，它可以存储任何变量的地址。这里不可以直接通过 \*P 来获取 unsafe\.Pointer 指针指向的那个变量的值，因为并不知道变量的具体类型。和普通的指针一样，unsafe\.Pointer 类型的指针是可比较的并且可以和 nil 做比较，nil 是指针类型的零值。  

## 查看浮点类型的位模式
一个普通的指针 \*T 可以转换为 unsafe\.Pointer 类型的指针，并且一个 unsafe\.Pointer 类型的指针也可以转换回普通的指针，被转换回普通指针的类型不需要和原来的 \*T 类型相同。这里有一个简单的应用场景，先将 \*float64 类型指针转化为 \*uint64 然后再把内存中的值打印出来。这时候就是按照 uint64 类型来把值打印出来，这样就可以看到浮点类型的变量在内存中的位模式：
```go
func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&f)) }

func main() {
	fmt.Printf("%#016x\n", Float64bits(1.0)) // "0x3ff0000000000000"
}
```

## 修改结构体成员的值
很多 unsafe\.Pointer 类型的值都是从普通指针到原始内存地址以及再从内存地址到普通指针进行转换的中间值。下面的例子获取变量 x 的地址，然后加上其成员 b 的地址偏移量，并将结果转换为 \*int16 指针类型，接着通过这个指针更新 x\.b 的值：
```go
var x struct {
	a bool
	b int16
	c []int
}

func main() {
	// 等价于 pb := &x.b ，但是这里是通过结构体的地址加上字段的偏移量计算后获取到的
	pb := (*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)))
	*pb = 42
	fmt.Println(x.b)
}
```
这里首先获取到结构体的地址，然后是成员的偏移量，相加后就是这个成员的内存地址。因为这里知道该地址指向的数据类型，所以直接用一个类型转换就获取到了成员 b 也就是 \*int16 的指针地址。既然拿到指针类型了，就可以修改该指针指向的变量的值了。  
这种方法不要随意使用。  

## 不要把 uintptr 类型赋值给临时变量
下面这段代码看似和上面的一样的，引入了一个临时变量 tmp，让把原来的一行拆成了两行，这里的 tmp 是 uintptr 类型。这种引入 uintptr 类型的临时变量，破坏原来整行代码的用法是错误的：
```go
func main() {
	tmp := uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)
	pb := (*int64)(unsafe.Pointer(tmp))
	*pb = 42
	fmt.Println(x.b)
}
```
原因很微妙。一些垃圾回收器会把内存中变量移来移去以减少内存碎片等问题。这种类型的垃圾回收器称为**移动GC**。当一个变量在内存中移动后，所有保存该变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾回收器的角度看，unsafe\.Pointer 是一个变量指针，当变量移动后它的值也会被更新。而 uintptr 仅仅是一个数值，在垃圾回收的时候这个值是不会变的。  

类似的错误用法还有像下面这样：
```go
pT := uintptr(unsafe.Pointer(new(T))) // 提示: 错误!
```
当垃圾回收器将会在语句执行结束后回收内存，在这之后，pT存储的是变量的旧地址，而这个时候这个地址对应的已经不是那个变量了。  

目前Go语言还没有使用移动GC，所以上面的错误用法很多时候是可以正确运行的（*运行了几次，都没有出错*）。但是还是存在其他移动变量的场景。  
这样的代码能够通过编译并运行，编译器不会报错，不过会给一个提示性的错误信息：
```
possible misuse of unsafe.Pointer
```
所以还是可以在编译的时候发现的。这里强烈建议遵守最小可用原则，不要使用任何包含变量地址的 uintptr 类型的变量，并减少不必要的 unsafe\.Pointer 类型到 uintptr 类型的转换。像本小节第一个例子里那样，转换为 uintptr 类型，最终在转换回 unsafe\.Pointer 类型的操作，都要在一条语句中完成。  

## reflect 包返回的 uintptr
当调用一个库函数，并且返回的是 uintptr 类型地址时，比如下面的 reflect 包中的几个函数。这些结果应该立刻转换为 unsafe\.Pointer 来确保它们在接下来代码中能够始终指向原来的变量：
```go
package reflect

func (Value) Pointer() uintptr
func (Value) UnsafeAddr() uintptr
func (Value) InterfaceData() [2]uintptr // (index 1)
```
一般的函数尽量不要返回 uintptr 类型，可能也就反射这类底层编程的包有这种情况。  
下一节的示例中会用到 reflect\.UnsafeAddr 函数，示例中立刻在同一行代码中就把返回值转成了 nsafe\.Pointer 类型。  

# 13.3 示例：深度相等
TODO: 这节会给一个工具函数 reflect.DeepEqual 来优化 11.2.5 中的测试。

# 13.5 关于安全的注意事项


# 13.4 使用 cgo 调用 C 代码
这里最好单独写一篇

# 扩展内容
「GCTT 出品」Cgo 和 Python：  
https://studygolang.com/articles/13019?fr=sidebar