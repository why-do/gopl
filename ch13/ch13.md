# 底层编程
主要内容：
+ unsafe 包
+ cgo 工具

包 unsafe 广泛使用在和操作系统交互的低级包中, 例如 runtime、os、syscall、net 等，但是普通程序是不需要使用它的。  

# 13.1 unsafe.Sizeof、Alignof 和 Offsetof
函数 unsafe\.Sizeof 报告传递给它的参数在内存中占用的字节（Byte）长度（1Byte=8bit，1个字节是8位），参数可以是任意类型的表达式，但它不会对表达式进行求值。对 Sizeof 的调用会返回一个 uintptr 类型的常量表达式，所以返回的结果可以作为数组类型的长度大小，或者用作计算其他的常量：
```go
fmt.Println(unsafe.Sizeof(float64(0))) // "8"
fmt.Println(unsafe.Sizeof(uint8(0))) // "1"
```
函数 Sizeof 仅报告每个数据结构固定部分的内存占用的字节长度。以字符串为例，报告的只是字符串对应的指针的字节长度，而不是字符串内容的长度：
```go
func main() {
	var x string
	x = "a"
	fmt.Println(unsafe.Sizeof(x), len(x)) // "16 1"

	var s []string
	for i := 0; i < 10000; i++ {
		s = append(s, "Hello")
	}
	x = strings.Join(s, ", ")
	fmt.Println(unsafe.Sizeof(x), len(x)) // "16 69998"
}
```
无论字符串多长，unsafe.Sizeof 返回的大小总是一样的。  

Go 语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小都是1个字（word），转换为字节数，在32位系统上是4个字节，在64位系统上是8个字节。  

| 类型 | 大小 |
|-----|-----|
| bool | 1个字节 |
| intN, uintN, floatN, complexN | N/8个字节(例如float64是8个字节) |
| int, uint, uintptr | 1个字 |
| *T | 1个字 |
| string | 2个字(data,len) |
| []T | 3个字(data,len,cap) |
| map | 1个字 |
| func | 1个字 |
| chan | 1个字 |
| interface | 2个字(type,value) |

## 内存对齐
在类型的值在内存中**对齐**的情况下，计算机的加载或者写入会很高效。例如，int16的大小是2字节地址应该是偶数，rune类型的大小是4字节地址应该是4的倍数，float64、uint64 或 64位指针的大小是8字节地址应该是8的倍数。对于更大倍数的地址对齐是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。  

**结构体的内存对齐**  
因此，聚合类型（结构体或数组）的值的长度至少是它的成员或元素的长度之和。并且由于“内存间隙”的存在，可能还会更大一些。内存空位是由编译器添加的未使用的内存地址，用来确保连续的成员或元素相对于结构体或数组的起始地址是对齐的。  
语言规范不要求结构体成员声明的顺序对应内存中的布局顺序，所以在理论上，编译器可以自由安排，但实际上并没有这么做。如果结构体成员的类型是不同的，不同的排列顺序可能使得结构体占用的内存不同。比如下面的三个结构体拥有相同的成员，但是第一种写法比其他两个定义需要占更多内存：
```go
                               // 64-bit  32-bit
struct{ bool; float64; int16 } // 3 words 4words
struct{ float64; int16; bool } // 2 words 3words
struct{ bool; int16; float64 } // 2 words 3words
```
对齐算法太底层了（虽然貌似也没有特别难），但确实不值得担心每个结构体的内存布局，不过高效排列可以使数据结构更加紧凑。一个容易掌握的建议是，将相同类型的成员定义在一起有可能更节约内存空间。

## 另两个函数
函数 unsafe\.Alignof 报告它参数类型所要求的对齐方式。和 Sizeof 一样，它的参数可以是任意类型的表达式，并且返回一个常量。通常情况下布尔和数值类型对齐到它们的长度(最多8个字节), 其它的类型则按字（word）对齐。  

函数 unsafe\.Offsetof，参数必须是结构体 x 的一个字段 x.f。函数返回 f 相对于结构体 x 起始地址的偏移值，如果有内存空位，也会计算在内。  

虽然这几个函数在不安全的unsafe包里，但是这几个函数是安全的，特别在需要优化内存空间时它们返回的结果对于理解原生的内存布局很有帮助。  

# 13.2 unsafe.Pointer

# 13.3
TODO: 这节会给一个工具函数 reflect.DeepEqual 来优化 11.2.5 中的测试。

# 扩展内容
「GCTT 出品」Cgo 和 Python：  
https://studygolang.com/articles/13019?fr=sidebar