# 底层编程
主要内容：
+ unsafe 包
+ cgo 工具

包 unsafe 广泛使用在和操作系统交互的低级包中, 例如 runtime、os、syscall、net 等，但是普通程序是不需要使用它的。  

# 13.1 unsafe.Sizeof、Alignof 和 Offsetof

函数 unsafe\.Sizeof 报告传递给它的参数在内存中占用的字节（Byte）长度（1Byte=8bit，1个字节是8位），参数可以是任意类型的表达式，但它不会对表达式进行求值。对 Sizeof 的调用会返回一个 uintptr 类型的常量表达式，所以返回的结果可以作为数组类型的长度大小，或者用作计算其他的常量：
```go
fmt.Println(unsafe.Sizeof(float64(0))) // "8"
fmt.Println(unsafe.Sizeof(uint8(0))) // "1"
```
函数 Sizeof 仅报告每个数据结构固定部分的内存占用的字节长度。以字符串为例，报告的只是字符串对应的指针的字节长度，而不是字符串内容的长度：
```go
func main() {
	var x string
	x = "a"
	fmt.Println(unsafe.Sizeof(x), len(x)) // "16 1"

	var s []string
	for i := 0; i < 10000; i++ {
		s = append(s, "Hello")
	}
	x = strings.Join(s, ", ")
	fmt.Println(unsafe.Sizeof(x), len(x)) // "16 69998"
}
```
无论字符串多长，unsafe.Sizeof 返回的大小总是一样的。  

Go 语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小都是1个字（word），转换为字节数，在32位系统上是4个字节，在64位系统上是8个字节。  



# 13.3
TODO: 这节会给一个工具函数 reflect.DeepEqual 来优化 11.2.5 中的测试。

# 扩展内容
「GCTT 出品」Cgo 和 Python：  
https://studygolang.com/articles/13019?fr=sidebar