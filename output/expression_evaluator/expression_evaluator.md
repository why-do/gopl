# 7.9 示例：表达式求值器
本篇将创建简单算术表达式的一个求值器。  

## 定义接口和类型
开始，先确定要使用一个接口 Expr 来代表这种语言的任意一个表达式。暂时没有任何方法，稍后再逐个添加：
```go
// Expr: 算术表达式
type Expr interface{}
```

我们的表达式语言将包括以下符号：
+ 浮点数字面量
+ 二元操作符：加减乘除（\+、\-、\*、\/）
+ 一元操作符：表示正数和负数的 \-x 和 \+x
+ 函数调用：pow(x,y)、sin(x) 和 sqrt(x)
+ 变量：比如 x、pi，自己定义一个变量名称，每次可以提供不用的值

还要有标准的操作符优先级，以及小括号。所有的值都是 float64 类型。  

下面是几个示例表达式：
```
sqrt(A / pi)
pow(x, 3) + pow(y, 3)
(F - 32) * 5 / 
```

下面5种具体类型代表特定类型的表达式：
+ Var ： 代表变量引用。这个类型是可导出的，至于为什么，后面会讲明
+ literal ： 代表浮点数常量
+ unary ： 代表有一个操作数的操作符表达式，操作数可以是任意的 Expr
+ binary ： 代表有两个操作数的操作符表达式，操作数可以是任意的 Expr
+ call ： 代表函数调用，这里限制它的 fn 字段只能是 pow、sin、sqrt

为了要计算包含变量的表达式，还需要一个上下文（environment）来把变量映射到数值。所有接口和类型的定义如下：
```go
// output/expression_evaluator/eval/ast.go
```
在定义好各种类型后，发现每个类型都需要提供一个 Eval 方法，于是加把这个方法加到接口中，已经添加到上面的代码中了。  
这个包只导出了 Expr、Var、Env。客户端可以在不接触其他表达式类型的情况下使用这个求值器。  

## 定义方法
接下来实现每个类型的 Eval 方法来满足接口。  

Var 的 Eval 方法从上下文中查询结果，如果变量不存在，则会返回0。  
literal 的 Eval 方法直接返回本身的值。  
unbary 的 Eval 方法首先对操作数递归求值，然后应用 op 操作符。  
binary 的 Eval 方法的处理逻辑和 unbary 一样。  
call 方法先对 pow、sin、sqrt 函数的参数求值，再调用 math 包中的对应函数。  
```go
// output/expression_evaluator/eval/eval.go
```

某些方法可能会失败，有些错误会导致 Eval 崩溃，还有些会导致返回不正确的结果。所有这些错误可以在求值之前做检查来发现，所以还需要一个Check方法。不过暂时可以先不管Check方法，而是先测试 Eval 方法。  

## Parse函数

## 测试函数
下面的 TestEval 函数用于测试 evaluator 