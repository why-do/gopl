# map实现集合
Go 没有提供集合类型，但是利用key唯一的特点，可以用map来实现这个功能。比如说字符串的集合：
```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	seen := make(map[string]bool) // 字符串集合
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		line := input.Text()
		if !seen[line] {
			seen[line] = true
			fmt.Println("Set:", line)
		}
	}
	if err := input.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "dedup: %v\n", err)
		os.Exit(1)
	}
}
```
从标准输出获取字符串，用map来存储已经出现过的行，只有首次出现的字符串才会打印出来。  

**使用空结构体作value**  
这里使用bool来作为map的value，而bool也有true和false两种值，而实际只使用了1种值。  
这里还可以使用空结构体（类型：struct{}、值：struct{}{}）。空结构体，没有长度，也不携带任何信息，用它可能是最合适的。但由于这种方式节约的内存很少并且语法复杂，所以一般尽量避免这样使用。  

# 位向量集合
Go 语言的集合通常使用 map[T]bool 来实现，其中T是元素类型。使用 map 的集合扩展性良好，但是对于一些特定的问题，一个专门设计过的集合性能会更优。比如，在数据流分析领域，集合元素都是小的非负整型，集合拥有许多元素，而且集合的操作多数是求并集和交集，**位向量**是个理想的数据结构。  
位向量使用一个无符号整形值的切片，每一位代表集合中的一个元素。如果设置第 i 位的元素，则表示集合包含 i。下面是一个包含了三个方法的简单位向量类型：
```go
// ch6/intset/intset.go
```
每一个 word 有64位，为了定位第 x 位的位置，通过 x/64 结果取整，就是 word 的索引，而 x%64 取模运算是 word 内位的索引。  
这里还自定义了以字符串输出 IntSet 的方法，就是一个 String 方法。在 String 方法中 bytes.Buffer 经常以这样的方式用到。  
因为 Add 方法和 UnionWith 方法需要对 s.word 进行赋值，所以需要用到指针。所以该类型的其他方法也都使用了指针，就是 Has 方法和 String 方法是不需要使用指针的，但是为了保持一致，就都使用指针作为方法的接收者。  

## 并集、交集、差集、对称差
上面只给了并集的示例，这里提到的4种集合的计算，简单参考一下 ch3.md 里的“位运算符”的介绍，很简单的通过修改一下位运算的符号就能实现了。  
并集和对称差，需要把s.words中没有的而t.words中多的那些元素全部加进来。而交集和差集，直接无视这部分元素就好了。  

## 计算置位个数
就是统计集合中元素的总数，查表法：
```go
// ch2/popcount/popcount.go
```
这部分是第二章的内容，加上习题一共3种算法：
1. 查表法：空间换时间。
2. 右移循环算法：最简单，最容易想到。
3. 快速法：如果输入整数中“1”远小于“0”（稀疏）,可以通过一些针对性算法来提高效率。

## 添加其他方法
添加 6.5 节的练习里的其他方法

## 自适应32或64位平台
这里每个字的类型都是 uint64，但是64位的计算在32位的平台上的效率不高。使用 uint 类型，这是适合平台的无符号整型。除以64的操作可以使用一个常量来代表32位或64位。  
这里有一个讨巧的表达式： 32<<(^uint(0)>>63) 。在不同的平台上计算的结果就是32或64。
```go
const bitCounts = 32 << (^uint(0) >> 63) // 使用这个常量去做取模和取余的计算
```