# 8.10 示例：聊天服务器
实现一个聊天服务器，它可以在几个用户之间相互广播文本消息。  
这个程序中有四种 goroutine：
+ 主 goroutine，就是 main 函数
+ 广播（broadcaster）goroutine。非常好的展示了 select 用法，因为它需要处理三种不同类型的消息
+ 每一个连接里有一个连接处理（handleConn）goroutine 
+ 每一个连接里还有一个客户写入（clientWriter）goroutine

## 主函数
主函数的工作是监听端口，接受连接请求。对每一个连接，它创建一个新的 handleConn。就像之前的并发回声服务器中那样：
```go
// main 函数
```

## 广播器
广播器，它的变量 clients 会记录当前连接的客户集合。其记录的内容是每一个客户端对外发送消息的通道：
```go
// 广播器
```
广播器监听两个全局的通道 entering 和 leaving。通过它们通知有客户进入和离开，如果从一个通道中接收到事件，它将更新 clients 集合。如果是客户离开，还会关闭对应客户对外发送消息的通道。  
广播器还监听 messages 通道，所有的客户都会将要广播的消息发送到这个通道。当收到一个消息后，就会把消息广播给所有客户。  

## 客户端处理函数
handleConn 函数创建一个对外发送消息的新通道，然后通过 entering 通道通知广播器新客户进入。接着，要读取客户发来的每一条消息，通过 messages 通道将每一条消息发送给广播器，发送时再每条消息前面加上发送者的ID作为前缀。一旦客户端将消息读取完毕，handleConn 通过 leaving 通道通知客户离开，然后关闭连接：
```go
// 客户端处理函数
```
另外，handleConn 函数还为每一个客户创建了写入（clientWriter）goroutine，每个客户都从自己的通道中接收消息发送给客户端的网络连接。在广播器收到 leaving 通知并关闭这个接收消息的通道后，clientWriter 会结束通道的遍历后运行结束。  

## 使用客户端进行聊天
和之前使用回声服务器一样，可以用 telnet 或者也可以用之前写的 netcat 作为客户端来聊天。  
当有 n 个客户 session 在连接的时候，程序并发运行着 2n+2 个相互通信的 goroutine，它不需要隐式的加锁操作也能做到并发安全。clients map 被限制在广播器这一个 goroutine 中，所以不会被并发的访问。唯一被多个 goroutine 共享的变量是通道以及 net\.Conn 的实例，它们也都是并发安全的。  