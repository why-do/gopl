# 8.10 示例：聊天服务器
实现一个聊天服务器，它可以在几个用户之间相互广播文本消息。  
这个程序中有四种 goroutine：
+ 主 goroutine，就是 main 函数
+ 广播（broadcaster）goroutine。非常好的展示了 select 用法，因为它需要处理三种不同类型的消息
+ 每一个连接里有一个连接处理（handleConn）goroutine 
+ 每一个连接里还有一个客户写入（clientWriter）goroutine

## 主函数
主函数的工作是监听端口，接受连接请求。对每一个连接，它创建一个新的 handleConn。就像之前的并发回声服务器中那样：
```go
// main 函数
```

## 广播器
广播器，它的变量 clients 会记录当前连接的客户集合。其记录的内容是每一个客户端对外发送消息的通道：
```go
// 广播器
```
广播器监听两个全局的通道 entering 和 leaving。通过它们通知有客户进入和离开，如果从一个通道中接收到事件，它将更新 clients 集合。如果是客户离开，还会关闭对应客户对外发送消息的通道。  
广播器还监听 messages 通道，所有的客户都会将要广播的消息发送到这个通道。当收到一个消息后，就会把消息广播给所有客户。  

## 客户端处理函数
handleConn 函数创建一个对外发送消息的新通道，然后通过 entering 通道通知广播器新客户进入。接着，要读取客户发来的每一条消息，通过 messages 通道将每一条消息发送给广播器，发送时再每条消息前面加上发送者的ID作为前缀。一旦客户端将消息读取完毕，handleConn 通过 leaving 通道通知客户离开，然后关闭连接：
```go
// 客户端处理函数: handleConn
```
另外，handleConn 函数还为每一个客户创建了写入（clientWriter）goroutine，每个客户都从自己的通道中接收消息发送给客户端的网络连接。在广播器收到 leaving 通知并关闭这个接收消息的通道后，clientWriter 会结束通道的遍历后运行结束：
```go
// 客户端处理函数: clientWriter
```
给客户端发送的消息字符串需要用"\\n"结尾。如果换成"\\r\\n"结尾，平台的兼容性应该会更好。至少windows上的telnet客户端可以直接使用了。  

## 使用客户端进行聊天
完整的源码就是上面的四段代码，拼在一起就能运行了。  
和之前使用回声服务器一样，可以用 telnet 或者也可以用之前写的 netcat 作为客户端来聊天。  
当有 n 个客户 session 在连接的时候，程序并发运行着 2n+2 个相互通信的 goroutine，它不需要隐式的加锁操作也能做到并发安全。clients map 被限制在广播器这一个 goroutine 中，所以不会被并发的访问。唯一被多个 goroutine 共享的变量是通道以及 net\.Conn 的实例，它们也都是并发安全的。  

# 聊天服务器功能扩展
上面的聊天服务器提供了一个很好的架构，现在再在其之上扩展功能就很方便了。  

## 通知当前的用户列表
在新用户到来之后，告知该新用户当前在聊天室的所有的用户列表。每个用户加入后，系统都会自动生成一个用户名（基于用户的网络连接，之后会添加设置用户名的功能），就是要把这些存在的用户名打印出来。  
所有的用户列表只在广播器的 clients map 中，但是这个 map 又不包括用户名。所以先要修改数据类型，把每个连接的数据结构加上一个新的用户名字段：
```go
type client chan<- string // 对外发送消息的通道
type clientInfo struct {
	name string
	ch   client
}
```
原本使用 client 作为元素的通道和 map，现在全部也都要换成 clientInfo 作为元素。像新用户发送当前用户列表的任务也在广播器中完成：
```go
// e12 广播器
```
客户端处理函数还需要做少量的修改，主要是因为数据结构变了。原本给 entering 和 leaving 通道发送的是 ch。现在要发送封装好 who 的结构体。客户端处理函数的代码略，之后的扩展中会贴出来：
```go
cli := clientInfo{who, ch}
entering <- cli
```

## 断掉长时间空闲的客户端
如果在一段时间里，客户端没有任何输入，服务器就将客户端断开。之前的逻辑是，客户端处理函数会一直在阻塞在 input.Scan() 这里等待客户端输入。只要在另外一个 goroutine 中调用 conn.Close()，就可以让当前阻塞的读操作变成非阻塞，就像 input.Scan() 输入完成的读操作一样。不过这么做的话会有一点小问题，原本在主 goroutine 的结尾有一个`conn.Close()`操作，现在在定时的 goroutine 中还需要有一个关闭的操作。如果因为定时而结束的，就会有两次关闭操作。  
这里关闭的是 socket 连接，本质上就是文件句柄。尝试多次关闭貌似不会有什么问题，不过要解决这个问题也不难。一种是把响应用户输入的操作也放到 goroutine 中。现有有两个 goroutine 在运行，主 goroutine 则只要一直阻塞，通过一个通道等待其中任何一个 goroutine 完成后发送的信号即可。这样关闭的操作只在主 goroutine 中操作。下面的是客户端处理函数，包括上一个功能里修改的部分：
```go
// e13 客户端处理函数: handleConn
```
这里还简单加了一个限制客户端发送空消息的功能，在 input.Scan() 循环中。空消息不会发送广播，但是可以重置定时器的时间。  