# 8.2 示例：并发时钟服务器
本节介绍 net 包，它提供构建客户端和服务器程序的组件，这些程序通过 TCP、UDP 或者 UNIX 套接字进行通信。网络服务 net\/http 包是在 net 包的基础上构建的。  

## 时钟服务器
这个示例是一个时钟服务器，它以每秒一次的频率向客户端发送当前时间：
```go
// ch8/clock1
```
Listen 函数创建一个 net\.Listener 对象，它在一个网络端口上监听进来的连接，这里是 TCP 端口 localhost:8000。监听器的 Accept 方法被阻塞，知道有连接请求进来，然后返回 net\.Conn 对象来代表一个连接。  
handleConn 函数处理一个完整的客户端连接。在循环里，它将 time.Now() 获取的当前时间发送给客户端。因为 net\.Conn 满足 io\.Writer 接口，所以可以直接向它进行写入。当写入失败时循环结束，很多时候是客户端断开连接，这是 handleConn 函数使用延迟（defer）的 Close 调用关闭自己这边的连接，然后继续等待下一个连接请求。  
为了连接到服务器，还需要一个 socket 客户端，这里可以先使用系统的 telnet 来进行验证：
```
$ telnet localhost 8000
```
这里可以开两个 telnet 尝试进行连接，只有第一个可以连接上，而其他的连接会阻塞。当把第一个客户端的连接断开后，服务端会重新返回到 main 函数的 for 循环中等待新的连接。此时之前阻塞的一个连接就能连接进来，继续显示时间。服务端程序暂时先这样，先来实现一个 socket 客户端程序。  

## 客户端 netcat
下面的客户端使用 net\.Dial 实现了 Go 版本的 netcat 程序，用来连接 TCP服务器：
```go
// ch8/netcat1
```
这个程序从网络连接中读取，然后写到标准输出，直到到达 EOF 或者出错。  

## 支持并发的服务器
如果打开多个客户端，同时只有一个客户端能正常工作。第二个客户端必须等到第一个结束才能正常工作，这是因为服务器是**顺序**的，一次只能处理一个客户请求。让服务器支持并发只需要一个很小的改变：在调用 handleConn 的地方添加一个 **go** 关键字，使它在自己的 goroutine 内执行：
```go
for {
	conn, err := listener.Accept()
	if err != nil {
		log.Print(err) // 例如，连接终止
		continue
	}
	go handleConn(conn) // 并发处理连接
}
```
现在的版本，多个客户端可以同时接入并正常工作了。  

# 8.3 示例：并发回声服务器
上面的时钟服务器每个连接使用一个 goroutine。下面要实现的这个回声服务器，每个连接使用多个 goroutine 来处理。大多数的回声服务器仅仅将读到的内容写回去，所以可以使用下面简单的 handleConn 版本：
```go
func handleConn(c net.Conn) {
	io.Copy(c, c)
	c.Close()
}
```

## 有趣的回声服务端
下面的这个版本可以重复3次，第一个全大写，第二次正常，第三次全消息：
```go
// ch8/reverb1
```
在上一个示例中，已经知道需要使用 go 关键字调用 handleConn 函数。不过在这个例子中，重点不是处理多个客户端的连接，所以这里不是重点。


## 升级客户端
现在来升级一下客户端，使它可以在终端上向服务器输入，还可以将服务器的回复复制到输出，这里提供了另一个使用并发的机会：
```go
// ch8/netcat2
```

## 优化服务端
使用上面的服务端版本，如果有多个连续的输入，新输入的内容不会马上返回，而是要等待之前输入的内容全部返回后才会处理之后的内容。要想做的更好，需要更多的 goroutine。再一次，在调用 echo 时需要加入 go 关键字：
```go
func handleConn(c net.Conn) {
	input := bufio.NewScanner(c)
	for input.Scan() {
		go echo(c, input.Text(), 1*time.Second)
	}
	// 注意：忽略 input.Err() 中可能的错误
	c.Close()
}
```
这个改进的版本，回声也是并发的，在时间上互相重合。  

## 小结
这就是使服务器变成并发所要做的，不仅处理来自多个客户端的链接，还包括在一个连接处理中，使用多个 go 关键字。在这个例子里，单个客户端连接也可以同时发起多个请求。在最初的版本里，没有使用 go 调用 echo，所以处理单个客户端的请求不是并发的，只有前一个处理完才会继续处理下一个。之后改进的版本，使用 go 调用 echo，这里对每一个请求的处理都是并发的了。  
然而，在添加这些 go 关键字的同时，必须要仔细考虑方法 net\.Conn 的并发调用是不是安全的，对大多数类型来讲，这都是不安全的。  