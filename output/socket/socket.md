# 8.2 示例：并发时钟服务器
本节介绍 net 包，它提供构建客户端和服务器程序的组件，这些程序通过 TCP、UDP 或者 UNIX 套接字进行通信。网络服务 net\/http 包是在 net 包的基础上构建的。  

## 时钟服务器
这个示例是一个时钟服务器，它以每秒一次的频率向客户端发送当前时间：
```go
// ch8/clock1
```
Listen 函数创建一个 net\.Listener 对象，它在一个网络端口上监听进来的连接，这里是 TCP 端口 localhost:8000。监听器的 Accept 方法被阻塞，知道有连接请求进来，然后返回 net\.Conn 对象来代表一个连接。  
handleConn 函数处理一个完整的客户端连接。在循环里，它将 time.Now() 获取的当前时间发送给客户端。因为 net\.Conn 满足 io\.Writer 接口，所以可以直接向它进行写入。当写入失败时循环结束，很多时候是客户端断开连接，这是 handleConn 函数使用延迟（defer）的 Close 调用关闭自己这边的连接，然后继续等待下一个连接请求。  
为了连接到服务器，还需要一个 socket 客户端，这里可以先使用系统的 telnet 来进行验证：
```
$ telnet localhost 8000
```
这里可以开两个 telnet 尝试进行连接，只有第一个可以连接上，而其他的连接会阻塞。当把第一个客户端的连接断开后，服务端会重新返回到 main 函数的 for 循环中等待新的连接。此时之前阻塞的一个连接就能连接进来，继续显示时间。服务端程序暂时先这样，先来实现一个 socket 客户端程序。  

## 客户端 netcat
下面的客户端使用 net\.Dial 实现了 Go 版本的 netcat 程序，用来连接 TCP服务器：
```go
// ch8/netcat1
```
这个程序从网络连接中读取，然后写到标准输出，直到到达 EOF 或者出错。  

## 支持并发的服务器
如果打开多个客户端，同时只有一个客户端能正常工作。第二个客户端必须等到第一个结束才能正常工作，这是因为服务器是**顺序**的，一次只能处理一个客户请求。让服务器支持并发只需要一个很小的改变：在调用 handleConn 的地方添加一个 **go** 关键字，使它在自己的 goroutine 内执行：
```go
for {
	conn, err := listener.Accept()
	if err != nil {
		log.Print(err) // 例如，连接终止
		continue
	}
	go handleConn(conn) // 并发处理连接
}
```
现在的版本，多个客户端可以同时接入并正常工作了。  