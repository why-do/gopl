# 基本数据

Go的数据类型分四大类：
1. 基础类型（basic type）
    + 数字（number）
    + 字符串（string）
    + 布尔型（boolean）
2. 聚合类型（aggregate type）
    + 数组（array）
    + 结构体（struct）
3. 引用类型（reference type）
    + 指针（pointer）
    + 切片（slice）
    + 散列表（map）
    + 函数（function）
    + 通道（channel）
4. 接口类型（interface type）

# 3.1 整数

## 二元操作符
二元操作符分五大优先级，按优先级降序排列：
```
*    /   %   <<  >>  &   &^
+    -   |   ^
==    !=  <   <=  >   >=
&&
||
```

## 位运算符
位运算符：
| 符号 | 说明 | 集合 |
| --- | --- | --- |
| & | AND | 交集 |
| \| | OR | 并集 |
| ^ | XOR | 对称差 |
| &^ | 位清空（AND NOT） | 差集 |
| << | 左移 | N/A |
| >> | 右移 | N/A |

位清空，表达式 z=x&^y ，把y中是1的位在x里对应的那个位，置0。  
差集，就是集合x去掉集合y中的元素之后的集合。对称差则是再加上集合y去掉集合x中的元素的集合，就是前后两个集合互相求差集，之后再并集。

## fmt的两个技巧（out）
一、%后的副词[1]告知Printf重复使用第一个操作数。  
二、%o、%x、%X之前的副词#告知Printf输出相应的前缀 0、0x、0X。  
```go
func main() {
	o := 0666
	fmt.Printf("%d %[1]o %#[1]o\n", o)  // 438 666 0666
	x := int64(0xdeadbeef)
	fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)  // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
}
```

# 3.4 布尔值

## 逻辑运算符
逻辑运算符 &&(AND) 以及 ||(OR) 的运算可能引起**短路行为**：如果运算符左边的操作数已经能够直接确定总体结果，则右边的操作数不会做计算。  
关于**优先级**，&& 较 || 优先级更高，这里有一个方便记忆的窍门。&& 表示逻辑乘法，|| 表示逻辑加法，这不仅仅指优先级，计算结果也很相似。  

## 布尔转数值
布尔值无法隐式转换成数值，反之也不行。如果需要把布尔值转成0或1，需要显示的使用if：
```go
i := 0
if b {
	i = 1
}
```
如果转换操作使用频繁，值得专门写成一个函数：
```go
func btoi(b bool) int {
	if b {
		return 1
    }
	return 0
}

func itob(i int) bool {
	return i != 0
}
```
反向转换比较简单，所以无需专门写成函数了。不过为了与btoi对应，上面也写了一个。

# 3.5 字符串

## 3.5.4 字符串和字节 slice

### bytes包
字节切片 []byte 类型，其某些属性和字符串相同。但是由于字符串不可变，因此按增量方式构建字符串会导致多次内存分配和复制。这种情况下，使用 bytes.Buffer 类型更高效。  
bytes 包为高效处理字节切片提供了 Buffer 类型。Buffer 初始值为空，其大小随着各种类型数据的写入而增长，如 string、byte 和 []byte。bytes.Buffer 变量无须初始化，其零值有意义：
```go
// ch3/printints
```
