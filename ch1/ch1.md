# 1.3 找出重复行

## bufio包，逐行读取（out）
关于bufio包，使用它可以简便和高效地处理输入和输出。其中一个最有用的特性是称为扫描器（Scanner）的类型，它可以读取输入，以行或者单词为单位断开，这是处理以行为单位输入内容的最简单方式。  
先声明一个 bufio.Scanner 类型的变量：
```go
input := bufio.NewScanner(os.Stdin)
```
扫描器从程序的标准输入进行读取。每一次调用 inout.Scan() 读取下一行，并且将结尾的换行符去掉；通过调用 input.Text() 来获取读到的内容。Scan 方法在读到新行的时候返回true，在没有更多内容的时候返回flase。  

## fmt格式化输出（out）
Printf 函数有超过10个各种转义字符，Go 程序员称为 verb。下表不完整，但是它说明了很多可用的功能：
| verb | 描述 |
|-----|-----|
| %d | 十进制数 |
| %x, %o, %b | 十六进制，八进制，二进制数 |
| %f, %g, %e | 浮点数 |
| %t | 布尔型 |
| %c | 字符（Unicode码点） |
| %s | 字符串 |
| %q | 带引号字符串或者字符 |
| %v | 内置格式的任何值 |
| %T | 任何值的类型 |
| %% | 百分号本身 |

以ln结尾的，比如fmt.Println，使用%v的方式来格式化参数，并且在最后追加换行符。

## 错误处理（out）
简单的错误处理是使用 Fprintf 和 %v 在标准错误流上输出一条消息，%v 可以使用默认格式显示任意类型的值。  
为了保持示例代码简短，有时会对错误处理有意进行一定程度的忽略。明显的错误还是要处理的。但是有些出现概率很小的错误，就忽略了，不过要标记所跳过的错误检查，就是加上注释。在5.4节还会更详细的讨论错误处理。  

# 1.6 并发获取多个 URL

## 读取内容并丢弃（out）
使用io.Copy函数读取响应的内容，比如直接复制内容到标准输出，这样就不需要把数据流装到缓冲区：
```go
n, err := io.Copy(os.Stdout, resp.Body)
```
还可以通过写入 ioutil.Discard 输出流进行丢弃，这样做之后就有了一个读取的过程，只要是为了获取返回的字节数：
```go
n, err := io.Copy(ioutil.Discard, resp.Body)
```