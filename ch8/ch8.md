# goroutine 和通道
Go 有两种并发编程风格：
+ goroutine 和通道（chennle），支持**通信顺序进程**（Communicating Sequential Process, CSP），CSP 是一个并发的模式，在不同的执行体（goroutine）之间传递值，但是变量本身局限于单一的执行体。
+ **共享内存多线程**的传统模型，和在其他主流语言中使用线程类似。

# 8.4 通道
如果说 goroutine 是 Go 程序并发的执行体，**通道**就是它们之间的连接。每一个通道是一个具体类型的导管，叫作通道的**元素类型**。  
像 map 一样，通道是一个使用 make 创建的数据结构的应用。当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用了同一份数据结构。和其他引用类型一样，通道的零值是 nil。  
通道有两个主要操作：**发送**（send）和**接收**（receive），两者统称为**通信**。通道还支持第三个操作：**关闭**（close），它设置一个标志位来指示值当前已经发送完毕。  
使用简单的 make 调用创建的通道叫**无缓冲（unbuffered）通道**，但 make 还可以接受第二个可选参数，一个表示通道**容量**的整数。如果容量是0，创建的也是无缓冲通道。  

## 8.4.1 无缓冲通道
使用无缓冲通道进行的通信导致发送和接收 goroutine **同步化**。因此无缓冲通道也称为**同步通道**。  
通过通道发送消息有两个重要的方面需要考虑：
+ 每条消息有一个值
+ 通信本身以及通信发生的时间。当我们强调这方面的时候，把消息叫做**事件**（event）

当事件没有携带额外的信息时，它单纯的目的是进行同步。和 map 实现的集合一样，可以使用一个 struct{} 元素类型的通道来强调它，尽管通常使用 bool 或 int 类型的通道来做相同的事情。因为`done <- 1`更简短。*书上讲集合的时候，使用的是 bool类型，这里讲事件同步，使用的是空结构体。*

## 8.4.2 管道
通道可以用来连接 goroutine，这样一个的输出是另一个的输入，这个叫**管道**（pipline）。  

**关闭通道**  
如果发送方知道没有更多的数据要发送，告诉接收者所在的 goroutine 可以停止等待是很有用的。这可以通过调用内置的 Close 函数来关闭通道：
```go
ch1 := make(chan bool) // 创建通道 ch1
// 下面是关闭通道
close(ch1)
```
在通道关闭后，任何后续的发送操作将会导致应用崩溃。当关闭的通道被**读完**（就是最后一个发送的值被接收）后，所有后续的接收操作都会立即返回，返回值是对应类型的零值。  
关闭通道还可以作为一个广播机制，后面的章节会具体讲。  

**检查通道的关闭**  
没有一个直接的方式来判断是否通道已经关闭，不过可以接收返回两个参数：接收到的元素，以及一个布尔值（通常是ok），返回 true 表示接收成功，返回 false 表示当前的接收操作在一个关闭的并且读完的通道上。*这个方法检查的也不是通道是否关闭了，而是通道里的值是否已经取完了。只有关闭的通道，才能保证不会有新值进入，把里面的值都取完后，会返回 false 表示这次取到的是通道关闭后的零值，而不是原本就是一个值为零的数据。*  

另外，还提供了一个 range 循环语法可以在通道上迭代。这个语法更为方便接收在通道上所有发送的值，接收完最后一个值后结束循环。  

**垃圾回收**  
结束时，关闭没一个通道不是必需的。只有在通知接收方 goroutine 所有的数据都发送完毕的时候才需要关闭通道。通道也可以通过垃圾回收器根据它是否可以访问来决定是否回收它，而不是根据它是否关闭。  

## 8.4.3 单向通道类型
Go 还提供了**单向通道**类型，仅仅导出发送或接收操作。类型`chan<- int`是一个**只能发送**的通道，允许发送单不允许接收。反之，类型`<-chan int`是一个**只能接收**的通道，允许接收但是不能发送。这里像箭头一样的操作符相对于 chan 关键字的位置是一个帮助记忆的点。如果违反这里的接收或发送的原则，在编译时会被检查出来。  
在函数定义时，指定了单向通道的类型。在函数调用时，依然是把正常定义的双向通道类型传值给函数的参数。函数的调用会隐式地将普通的通道类型转化为要求的单向通道的类型。在任何赋值操作中将双向通道转换为单向通道都是允许的，但是反过来是不行的。一旦有一个单向通道，是没有办法通过它获取到引用同一个数据结构的双向通道的类型的。  

## 8.4.4 缓冲通道
缓冲通道有一个元素队列，队列的最大长度在创建的时候通过 make 的容量参数来设置：
```go
ch1 := make(chan string, 3)
```
通过调用内置的 cap 函数，可以获取通道缓冲区的容量。这种需求不太常见。  
通过调用内置的 len 函数，可以获取通道内的元素个数。不过在并发程序中这个信息会随着检索操作很快过时，所以它的价值很低，但是它在错误诊断和性能优化的时候很有用。  

**这不是队列**  
发送和接收操作可以在同一个 goroutine 中，但在真实的程序中通常由不同的 goroutine 执行。因为语法简单，新手有时候粗暴地将缓冲通道作为队列在单个 goroutine 中使用，但是这是个错误的用法。通道和 goroutine 的调度深度关联，如果没有另一个 goroutine 从通道进行接收，发送者（也许是整个程序）有被永久阻塞的风险。如果仅仅需要一个简单的队列，使用切片创建一个就好了。  

**示例：并发请求最快的镜像资源**  
下面的例子展示一个使用缓冲通道的应用。它并发地向三个**镜像地址**发请求，镜像指相同但分布在不同地理区域的服务器。它将它们的响应通过一个缓冲通道进行发送，然后只接收第一个返回的响应，因为它是最早到达的。所以 mirroredQuery 函数甚至在两个比较慢的服务器还没有响应之前返回了一个结果。（偶然情况下，会出现像这个例子中的几个 goroutine 同时在一个通道上并发发送，或者同时从一个通道接收的情况。）：
```go
func mirroredQuery() string {
	responses := make(chan string, 3) // 有几个镜像，就要多大的容量，不能少
	go func () { responses <- request("asia.gopl.io") }()
	go func () { responses <- request("europe.gopl.io") }()
	go func () { responses <- request("americas.gopl.io") }()
	return <- responses // 返回最快一个获取到的请求结果
}

func request(hostname string) (response string) { return "省略获取返回的代码" }
```

**goroutine 泄露**  
在上面的示例中，如果使用的是无缓冲通道，两个比较慢的 goroutine 将被卡住，因为在它们发送响应结果到通道的时候没有 goroutine 来接收。这个情况叫做 **goroutine 泄漏**。它属于一个 bug。不像回收变量，泄漏的 goroutine 不会自动回收，所以要确保 goroutine 在不再需要的时候可以自动结束。  

## 通道缓冲的选择
无缓冲和缓冲通道的选择，缓冲通道容量大小的选择，都会对程序的正确性产生影响。无缓冲通道提供强同步保障，因为每一次发送都需要和一次对应的接收同步；对于缓冲通道，这些操作则是解耦的。如果知道要发送的值数量的上限，通常会创建一个容量是使用上限的缓冲通道，在接收第一个值前就完成所有的发送。在内存无法提供缓冲容量的情况下，可能导致程序死锁。  

TODO： 通道缓冲对程序性能的影响。蛋糕店示例：
TODO: gopl.io/ch8/cake ，性能基准（参考 11.4 节）

# 8.5 并行循环
重申了 5.6.1 里提到的**捕获迭代变量**的问题，这次是在 goroutine 中的情况，和避免方式。  
TODO：生成图像的缩略图，gopl.io/ch8/thumbnail 包提供的 ImageFile 函数，书上不展示这个函数的细节。  

