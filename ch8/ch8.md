# goroutine 和通道
Go 有两种并发编程风格：
+ goroutine 和通道（chennle），支持**通信顺序进程**（Communicating Sequential Process, CSP），CSP 是一个并发的模式，在不同的执行体（goroutine）之间传递值，但是变量本身局限于单一的执行体。
+ **共享内存多线程**的传统模型，和在其他主流语言中使用线程类似。

# 8.4 通道
如果说 goroutine 是 Go 程序并发的执行体，**通道**就是它们之间的连接。每一个通道是一个具体类型的导管，叫作通道的**元素类型**。  
像 map 一样，通道是一个使用 make 创建的数据结构的应用。当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用了同一份数据结构。和其他引用类型一样，通道的零值是 nil。  
通道有两个主要操作：**发送**（send）和**接收**（receive），两者统称为**通信**。通道还支持第三个操作：**关闭**（close），它设置一个标志位来指示值当前已经发送完毕。  
使用简单的 make 调用创建的通道叫**无缓冲（unbuffered）通道**，但 make 还可以接受第二个可选参数，一个表示通道**容量**的整数。如果容量是0，创建的也是无缓冲通道。  

## 8.4.1 无缓冲通道
使用无缓冲通道进行的通信导致发送和接收 goroutine **同步化**。因此无缓冲通道也称为**同步通道**。  
通过通道发送消息有两个重要的方面需要考虑：
+ 每条消息有一个值
+ 通信本身以及通信发生的时间。当我们强调这方面的时候，把消息叫做**事件**（event）

当事件没有携带额外的信息时，它单纯的目的是进行同步。和 map 实现的集合一样，可以使用一个 struct{} 元素类型的通道来强调它，尽管通常使用 bool 或 int 类型的通道来做相同的事情。因为`done <- 1`更简短。*书上讲集合的时候，使用的是 bool类型，这里讲事件同步，使用的是空结构体。*

# 
TODO：ch5.md 捕获迭代变量