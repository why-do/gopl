# goroutine 和通道
Go 有两种并发编程风格：
+ goroutine 和通道（chennle），支持**通信顺序进程**（Communicating Sequential Process, CSP），CSP 是一个并发的模式，在不同的执行体（goroutine）之间传递值，但是变量本身局限于单一的执行体。
+ **共享内存多线程**的传统模型，和在其他主流语言中使用线程类似。

# 8.4 通道
如果说 goroutine 是 Go 程序并发的执行体，**通道**就是它们之间的连接。每一个通道是一个具体类型的导管，叫作通道的**元素类型**。  
像 map 一样，通道是一个使用 make 创建的数据结构的应用。当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用了同一份数据结构。和其他引用类型一样，通道的零值是 nil。  
通道有两个主要操作：**发送**（send）和**接收**（receive），两者统称为**通信**。通道还支持第三个操作：**关闭**（close），它设置一个标志位来指示值当前已经发送完毕。  
使用简单的 make 调用创建的通道叫**无缓冲（unbuffered）通道**，但 make 还可以接受第二个可选参数，一个表示通道**容量**的整数。如果容量是0，创建的也是无缓冲通道。  

## 8.4.1 无缓冲通道
使用无缓冲通道进行的通信导致发送和接收 goroutine **同步化**。因此无缓冲通道也称为**同步通道**。  
通过通道发送消息有两个重要的方面需要考虑：
+ 每条消息有一个值
+ 通信本身以及通信发生的时间。当我们强调这方面的时候，把消息叫做**事件**（event）

当事件没有携带额外的信息时，它单纯的目的是进行同步。和 map 实现的集合一样，可以使用一个 struct{} 元素类型的通道来强调它，尽管通常使用 bool 或 int 类型的通道来做相同的事情。因为`done <- 1`更简短。*书上讲集合的时候，使用的是 bool类型，这里讲事件同步，使用的是空结构体。*

## 8.4.2 管道
通道可以用来连接 goroutine，这样一个的输出是另一个的输入，这个叫**管道**（pipline）。  

**关闭通道**  
如果发送方知道没有更多的数据要发送，告诉接收者所在的 goroutine 可以停止等待是很有用的。这可以通过调用内置的 Close 函数来关闭通道：
```go
ch1 := make(chan bool) // 创建通道 ch1
// 下面是关闭通道
close(ch1)
```
在通道关闭后，任何后续的发送操作将会导致应用崩溃。当关闭的通道被**读完**（就是最后一个发送的值被接收）后，所有后续的接收操作都会立即返回，返回值是对应类型的零值。  
关闭通道还可以作为一个广播机制，后面的章节会具体讲。  

**检查通道的关闭**  
没有一个直接的方式来判断是否通道已经关闭，不过可以接收返回两个参数：接收到的元素，以及一个布尔值（通常是ok），返回 true 表示接收成功，返回 false 表示当前的接收操作在一个关闭的并且读完的通道上。*这个方法检查的也不是通道是否关闭了，而是通道里的值是否已经取完了。只有关闭的通道，才能保证不会有新值进入，把里面的值都取完后，会返回 false 表示这次取到的是通道关闭后的零值，而不是原本就是一个值为零的数据。*  

另外，还提供了一个 range 循环语法可以在通道上迭代。这个语法更为方便接收在通道上所有发送的值，接收完最后一个值后结束循环。  

**垃圾回收**  
结束时，关闭没一个通道不是必需的。只有在通知接收方 goroutine 所有的数据都发送完毕的时候才需要关闭通道。通道也可以通过垃圾回收器根据它是否可以访问来决定是否回收它，而不是根据它是否关闭。  

# 
TODO：ch5.md 捕获迭代变量