# goroutine 和通道
Go 有两种并发编程风格：
+ goroutine 和通道（chennle），支持**通信顺序进程**（Communicating Sequential Process, CSP），CSP 是一个并发的模式，在不同的执行体（goroutine）之间传递值，但是变量本身局限于单一的执行体。
+ **共享内存多线程**的传统模型，和在其他主流语言中使用线程类似。

# 8.4 通道
如果说 goroutine 是 Go 程序并发的执行体，**通道**就是它们之间的连接。每一个通道是一个具体类型的导管，叫作通道的**元素类型**。  
像 map 一样，通道是一个使用 make 创建的数据结构的应用。当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用了同一份数据结构。和其他引用类型一样，通道的零值是 nil。  
通道有两个主要操作：**发送**（send）和**接收**（receive），两者统称为**通信**。通道还支持第三个操作：**关闭**（close），它设置一个标志位来指示值当前已经发送完毕。  
使用简单的 make 调用创建的通道叫**无缓冲（unbuffered）通道**，但 make 还可以接受第二个可选参数，一个表示通道**容量**的整数。如果容量是0，创建的也是无缓冲通道。  

## 8.4.1 无缓冲通道
使用无缓冲通道进行的通信导致发送和接收 goroutine **同步化**。因此无缓冲通道也称为**同步通道**。  
通过通道发送消息有两个重要的方面需要考虑：
+ 每条消息有一个值
+ 通信本身以及通信发生的时间。当我们强调这方面的时候，把消息叫做**事件**（event）

当事件没有携带额外的信息时，它单纯的目的是进行同步。和 map 实现的集合一样，可以使用一个 struct{} 元素类型的通道来强调它，尽管通常使用 bool 或 int 类型的通道来做相同的事情。因为`done <- 1`更简短。*书上讲集合的时候，使用的是 bool类型，这里讲事件同步，使用的是空结构体。*

## 8.4.2 管道
通道可以用来连接 goroutine，这样一个的输出是另一个的输入，这个叫**管道**（pipline）。  

**关闭通道**  
如果发送方知道没有更多的数据要发送，告诉接收者所在的 goroutine 可以停止等待是很有用的。这可以通过调用内置的 Close 函数来关闭通道：
```go
ch1 := make(chan bool) // 创建通道 ch1
// 下面是关闭通道
close(ch1)
```
在通道关闭后，任何后续的发送操作将会导致应用崩溃。当关闭的通道被**读完**（就是最后一个发送的值被接收）后，所有后续的接收操作都会立即返回，返回值是对应类型的零值。  
关闭通道还可以作为一个广播机制，后面的章节会具体讲。  

**检查通道的关闭**  
没有一个直接的方式来判断是否通道已经关闭，不过可以接收返回两个参数：接收到的元素，以及一个布尔值（通常是ok），返回 true 表示接收成功，返回 false 表示当前的接收操作在一个关闭的并且读完的通道上。*这个方法检查的也不是通道是否关闭了，而是通道里的值是否已经取完了。只有关闭的通道，才能保证不会有新值进入，把里面的值都取完后，会返回 false 表示这次取到的是通道关闭后的零值，而不是原本就是一个值为零的数据。*  

另外，还提供了一个 range 循环语法可以在通道上迭代。这个语法更为方便接收在通道上所有发送的值，接收完最后一个值后结束循环。  

**垃圾回收**  
结束时，关闭没一个通道不是必需的。只有在通知接收方 goroutine 所有的数据都发送完毕的时候才需要关闭通道。通道也可以通过垃圾回收器根据它是否可以访问来决定是否回收它，而不是根据它是否关闭。  

## 8.4.3 单向通道类型
Go 还提供了**单向通道**类型，仅仅导出发送或接收操作。类型`chan<- int`是一个**只能发送**的通道，允许发送单不允许接收。反之，类型`<-chan int`是一个**只能接收**的通道，允许接收但是不能发送。这里像箭头一样的操作符相对于 chan 关键字的位置是一个帮助记忆的点。如果违反这里的接收或发送的原则，在编译时会被检查出来。  
在函数定义时，指定了单向通道的类型。在函数调用时，依然是把正常定义的双向通道类型传值给函数的参数。函数的调用会隐式地将普通的通道类型转化为要求的单向通道的类型。在任何赋值操作中将双向通道转换为单向通道都是允许的，但是反过来是不行的。一旦有一个单向通道，是没有办法通过它获取到引用同一个数据结构的双向通道的类型的。  

## 8.4.4 缓冲通道
缓冲通道有一个元素队列，队列的最大长度在创建的时候通过 make 的容量参数来设置：
```go
ch1 := make(chan string, 3)
```
通过调用内置的 cap 函数，可以获取通道缓冲区的容量。这种需求不太常见。  
通过调用内置的 len 函数，可以获取通道内的元素个数。不过在并发程序中这个信息会随着检索操作很快过时，所以它的价值很低，但是它在错误诊断和性能优化的时候很有用。  

**这不是队列**  
发送和接收操作可以在同一个 goroutine 中，但在真实的程序中通常由不同的 goroutine 执行。因为语法简单，新手有时候粗暴地将缓冲通道作为队列在单个 goroutine 中使用，但是这是个错误的用法。通道和 goroutine 的调度深度关联，如果没有另一个 goroutine 从通道进行接收，发送者（也许是整个程序）有被永久阻塞的风险。如果仅仅需要一个简单的队列，使用切片创建一个就好了。  

**示例：并发请求最快的镜像资源**  
下面的例子展示一个使用缓冲通道的应用。它并发地向三个**镜像地址**发请求，镜像指相同但分布在不同地理区域的服务器。它将它们的响应通过一个缓冲通道进行发送，然后只接收第一个返回的响应，因为它是最早到达的。所以 mirroredQuery 函数甚至在两个比较慢的服务器还没有响应之前返回了一个结果。（偶然情况下，会出现像这个例子中的几个 goroutine 同时在一个通道上并发发送，或者同时从一个通道接收的情况。）：
```go
func mirroredQuery() string {
	responses := make(chan string, 3) // 有几个镜像，就要多大的容量，不能少
	go func () { responses <- request("asia.gopl.io") }()
	go func () { responses <- request("europe.gopl.io") }()
	go func () { responses <- request("americas.gopl.io") }()
	return <- responses // 返回最快一个获取到的请求结果
}

func request(hostname string) (response string) { return "省略获取返回的代码" }
```

**goroutine 泄露**  
在上面的示例中，如果使用的是无缓冲通道，两个比较慢的 goroutine 将被卡住，因为在它们发送响应结果到通道的时候没有 goroutine 来接收。这个情况叫做 **goroutine 泄漏**。它属于一个 bug。不像回收变量，泄漏的 goroutine 不会自动回收，所以要确保 goroutine 在不再需要的时候可以自动结束。  

## 通道缓冲的选择
无缓冲和缓冲通道的选择，缓冲通道容量大小的选择，都会对程序的正确性产生影响。无缓冲通道提供强同步保障，因为每一次发送都需要和一次对应的接收同步；对于缓冲通道，这些操作则是解耦的。如果知道要发送的值数量的上限，通常会创建一个容量是使用上限的缓冲通道，在接收第一个值前就完成所有的发送。在内存无法提供缓冲容量的情况下，可能导致程序死锁。  

TODO： 通道缓冲对程序性能的影响。蛋糕店示例：
TODO: gopl.io/ch8/cake ，性能基准（参考 11.4 节）

# 8.5 并行循环
重申了 5.6.1 里提到的**捕获迭代变量**的问题，这次是在 goroutine 中的情况，和避免方式。  
TODO：生成图像的缩略图，gopl.io/ch8/thumbnail 包提供的 ImageFile 函数，书上不展示这个函数的细节。  

# 8.7 使用 select 多路复用
有时候需要在多个通道上接收，不能只从一个通道上接收，因为任何一个操作都会在完成前阻塞。所以需要**多路复用**那些操作过程，为了实现这个目的，需要一个 select 语句：
```go
select {
case <-ch1:
	// ...
case x := <-ch2:
	// ...use x...
case ch3 <- y:
	// ...
default:
	// ...
}
```
上面展示的是 select 语句的通用形式。像 switch 语句一样，它有一系列的情况和一个可选的默认分支。每一个情况指定一次**通信**（在一些通道上进行发送或接收操作）和关联的一段代码块。接收表达式操作可能出现在它本身上，像第一个情况，或者在一个短变量声明中，像第二个情况。第二种形式可以让你引用所接收的值。  
select 一直等待，直到一次通信来告知有一些情况可以执行。然后，它进行这次通信，执行此情况所对应的语句，其他的通信将不会发生。  

## 使用示例
下面是一个微妙的例子。通道 ch 的缓冲区大小为 1，它要么是空的，要么是满的，因此只有在其中一个状况下可以执行，要么在 i 是偶数时发送，要么在 i 是奇数时接收。它总是输出 0 2 4 6 8：
```go
func main() {
	ch := make(chan int, 1)
	for i := 0; i < 10; i++ {
		select {
		case x := <-ch:
			fmt.Println(x)
		case ch <- i:
		}
	}
}
```
如果多个情况同时满足，select 随机选择一个，这样保证每一个通道有相同的机会被选中。在前一个例子中增加缓冲区的容量，会使输出变得不可确定，因为当缓冲既不空也不满的情况，相当于 select 语句在随机做选择。  
## 非阻塞模式
有时候我们试图在一个通道上发送或接收，但是不想在通道没有准备好的情况下被阻塞，**非阻塞通信**。这使用 select 语句也可以做到。select 可以有一个默认情况，它用来指定在没有其他的通信发生时可以立即执行的动作。  
下面的 select 语句尝试从 abort 通道中接收一个值，如果没有值，它什么也不做。这是一个非阻塞的接收操作。重复这个动作称为对通道**轮询**：
```go
select {
case <-abort:
	fmt.Println("Launch aborted!")
	return
default:
	// 不执行任何操作
}
```

## 通道的零值
通道的零值是 nil。令人惊讶的是，nil 通道有时候很有用。因为在 nil 通道上发送和接收将永远阻塞。对于 select 语句中的情况，如果其通道是 nil，它将永远不会被选择。可以用 nil 来开启或禁用特性所对应的情况，比如超时处理或者取消操作，响应其他的输入事件或者发送事件。  

# 8.8 示例：并发目录遍历
这里要构建一个程序，根据命令行指定的输入，报告一个或多个目录的磁盘使用情况，类似 UNIX 的 du 命令。  

## 递归遍历目录
大多数的工作由下面的 walkDir 函数完成，它使用 dirents 辅助函数来枚举目录中的条目：
```go
// walkDir 递归地遍历以 dir 为根目录的整个文件树
// 并在 fileSizes 上发送每个已找到的文件的大小
func walkDir(dir string, fileSizes chan<- int64) {
	for _, entry := range dirents(dir) {
		if entry.IsDir() {
			subdir := filepath.Join(dir, entry.Name())
			walkDir(subdir, fileSizes)
		} else {
			fileSizes <- entry.Size()
		}
	}
}

// dirents 返回 dir 目录中的条目
func dirents(dir string) []os.FileInfo {
	entries, err := ioutil.ReadDir(dir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "du1: %v\n", err)
		return nil
	}
	return entries
}
```
ioutil\.ReadDir 函数返回一个 os\.FileInfo 类型的切片，针对单个文件同样的信息可以通过调用 os\.Stat 函数来返回。对每一个子目录，walkDir 递归调用它自己，对于每一个文件，walkDir 发送一条消息到 fileSizes 通道。消息是文件所占用的字节数。  

## 计算大小并输出
下面的 main 函数使用两个 goroutine。后台 goroutine 调用 walkDir 遍历命令行上指定的每一个目录，最后关闭 fileSizes 通道。主 goroutine 计算从通道中接收的文件的大小的和，最后输出总数：
```go
func main() {
	// 确定初始目录
	flag.Parse()
	roots := flag.Args()
	if len(roots) == 0 {
		roots = []string{"."}
	}
	// 遍历文件树
	fileSizes := make(chan int64)
	go func() {
		for _, root := range roots {
			walkDir(root, fileSizes)
		}
		close(fileSizes)
	}()
	// 输出结果
	var nfiles, nbytes int64
	for size := range fileSizes {
		nfiles++
		nbytes += size
	}
	printDiskUsage(nfiles, nbytes)
}

func printDiskUsage(nfiles, nbytes int64) {
	fmt.Printf("%d files   %.2f GB\n", nfiles, float64(nbytes)/(1<<30)) // 1<<30 就是 2**30 就是 1024*1024*1024
}
```
现在程序可以正常的工作。

## 汇报进度