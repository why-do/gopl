# 8.2 示例：并发时钟服务器
+ 练习8.1：修改 clock2 来接收一个端口号，写一个程序 clockwall，作为多个时钟服务器的客户端，读取每一个服务器的时间，类似于不同地区办公室的时钟，然后显示在一个表中。如果可以访问不同地域的计算机，可以远程运行示例程序；否则可以伪装不同的地区，在不同的端口收本地运行：
```
$ TZ=US/Eastern ./clock2 -port 8010 &
$ TZ=Asia/Tokyo ./clock2 -port 8020 &
$ TZ=Europe/London ./clock2 -port 8030 &
$ clockwall NewYork=localhost:8010 London=localhost:8020 Tokyo=localhost:8030
```
+ 练习8.2：实现一个并发的 FTP 服务器。服务器可以解释从客户端发来的命令，例如 cd 用来改变目录，ls 用来列出目录，get 用来发送一个文件的内容，close 用来关闭连接。可以使用标准的 ftp 命令作为客户端，或者自己写一个。

# 8.4.1 无缓冲通道
+ 练习8.3：在 netcat3 中，conn 接口有一个具体的类型 \*net\.TCPConn，它代表一个 TCP 连接。TCP 链接由两半边组成，可以通过 CloseRead 和 CloseWrite 方法分别关闭。修改主 goroutine，仅仅关闭连接的写半边，这样程序可以继续执行输出来自 reverb1 服务器的回声，即使标准输入已经关闭。（对 reverb2 程序来说更难一些，见练习 8.4。）

# 8.5 并行循环
+ 练习8.4：修改 reverb2 程序来使用 sync.WaitGroup  来计算每一个连接上面的活动的回声 goroutine 的个数。当它变成 0 时，关闭练习 8.3 中描述的写半边的 TCP 链接。验证你修改好的 netcat3 客户端，等待最后几个并发的呼喊回声，即使标准输入已经关闭。
+ 练习8.5：使用一个已有的 CPU 绑定的顺序程序，例如 3.3 节的 mandelbrot 程序（复数分形图），或者 3.2 节的 3D 平面计算（浮点数和SVG图），在主循环中并行执行它们，使用通道来通信。在多 CPU 的机器上它的运行速度有多快？goroutine 的最优数量是多少？

# 8.6 示例：并发的 Web 爬虫
+ 练习8.6：对并发爬虫添加深度限制。如果用户设置 -depth=3，那么仅最多通过三个链接可达的 URL 能被找到。
+ 练习8.7：写一个并发程序来创建一个网站的本地镜像，获取它每一个可达的页面，然后将它们写到本地磁盘上的目录。只能获取本域的页面（例如，golang.org）。镜像页面内的 URL 按需调整，因为它们应该应用镜像页面，而不是原始页面。

# 8.7 使用 select 多路复用
+ 练习8.8：使用 select 语句，给 8.3 节的回声服务器加一个超时，这样可以断开 10s 内没有任何呼叫的客户端。

# 8.8 示例：并发目录遍历
+ 练习8.9：写一个 du 版本，它可以为每一个指定的 root 目录计算和定期输出各自占用的总空间。

# 8.9 取消
+ 练习8.10：HTTP 请求可以通过关闭 http.Request 结构中可选的 Cancel 通道进行取消。修改 8.6 节的网页爬虫使其支持取消操作。
提示：http.Get 便利函数没有提供定制 Request 的机会。使用 http.NewRequest 创建请求，设置它的 Cancel 字段，然后调用 http.DefaultClient.Do(req) 来执行请求。  
+ 练习8.11：使用 8.4.4 节的 mirroredQuery 程序中的方法，实现 fetch 的一个变种，它并发请求多个 URL，当第一个响应返回的时候，取消其他的请求。
+ TODO：练习1.11

# 8.10 示例：聊天服务器
+ 练习8.12：让广播者在每一个新客户到来的时候通知当前存在的客户。这也要求 clients 集合以及 entering 和 leaving 通道记录客户的名字。
+ 练习8.13：使聊天服务器可以断掉长时间空置的连接，例如在过去5分钟里没有发送过消息的连接。提示：在另一个 goroutine 中调用 conn.Close()，可以让当前阻塞的读操作变成非阻塞，就像 input.Scan() 输入完成的读操作一样。
+ 练习8.14：改变聊天服务器的网络交互协议，让客户端可以输入它的名字。使用名字来代替网络地址作为发送者的ID，作为每一条消息的前缀。
+ 练习8.15：任何客户程序读取数据的时间很长最终会造成所有的客户卡住。修改广播器，使它满足如果一个向客户写入的通道没有准备好接受它，那么跳过这条消息。还可以给每一个向客户发送消息的通道增加缓冲，这样大多数的消息不会丢弃；广播器在这个通道上应该使用非阻塞的发送方式。